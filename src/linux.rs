/* automatically generated by rust-bindgen 0.69.5 */

#[doc = "Plugin Instance Handle.\n\nThis is a handle for one particular instance of a plugin.  It is valid to\ncompare to NULL (or 0 for C++) but otherwise the host MUST NOT attempt to\ninterpret it."]
pub type LV2_Handle = *mut ::std::os::raw::c_void;
#[doc = "Feature.\n\nFeatures allow hosts to make additional functionality available to plugins\nwithout requiring modification to the LV2 API.  Extensions may define new\nfeatures and specify the `URI` and `data` to be used if necessary.\nSome features, such as lv2:isLive, do not require the host to pass data."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LV2_Feature {
    #[doc = "A globally unique, case-sensitive identifier (URI) for this feature.\n\nThis MUST be a valid URI string as defined by RFC 3986."]
    pub URI: *const ::std::os::raw::c_char,
    #[doc = "Pointer to arbitrary data.\n\nThe format of this data is defined by the extension which describes the\nfeature with the given `URI`."]
    pub data: *mut ::std::os::raw::c_void,
}
#[doc = "< Plugin is licensed."]
pub const MOD_License_Status_MOD_LICENSE_SUCCESS: MOD_License_Status = 0;
#[doc = "< Unknown error."]
pub const MOD_License_Status_MOD_LICENSE_ERR_UNKNOWN: MOD_License_Status = 1;
#[doc = "< Plugin is not licensed - will run in restricted/demo mode."]
pub const MOD_License_Status_MOD_LICENSE_ERR_UNLICENSED: MOD_License_Status = 2;
#[doc = "< Plugin does not support this license API."]
pub const MOD_License_Status_MOD_LICENSE_ERR_UNSUPPORTED: MOD_License_Status = 3;
#[doc = "Status code for license functions."]
pub type MOD_License_Status = ::std::os::raw::c_uint;
#[doc = "MOD License Interface.\n\nWhen the plugin's extension_data is called with argument\nMOD_LICENSE__interface, the plugin MUST return an MOD_License_Interface\nstructure, which remains valid for the lifetime of the plugin.\n\nThe host can use the contained function pointers to query information about\na plugin's license. This can be used by the host to provide information to\nthe GUI (e.g. display name of licensee)."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOD_License_Interface {
    #[doc = "Get the current license status for a plugin instance.\n\n@see MOD_License_Status\n\n@param instance The LV2 instance this is a method on."]
    pub status:
        ::std::option::Option<unsafe extern "C" fn(instance: LV2_Handle) -> ::std::os::raw::c_int>,
    #[doc = "Get the name of the licensee for a plugin instance.\nThe caller is responsible for freeing the returned value with free().\n\n@param instance The LV2 instance this is a method on."]
    pub licensee: ::std::option::Option<
        unsafe extern "C" fn(instance: LV2_Handle) -> *mut ::std::os::raw::c_char,
    >,
}
#[doc = "MOD License Interface.\n\nWhen the plugin's extension_data is called with argument\nMOD_LICENSE__interface, the plugin MUST return an MOD_License_Interface\nstructure, which remains valid for the lifetime of the plugin.\n\nThe host can use the contained function pointers to query information about\na plugin's license. This can be used by the host to provide information to\nthe GUI (e.g. display name of licensee)."]
pub type MOD_License_Interface = _MOD_License_Interface;
#[doc = "Opaque pointer to host data for MOD_License_Feature."]
pub type MOD_License_Handle = *mut ::std::os::raw::c_void;
#[doc = "MOD License Feature (MOD_LICENSE__feature)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _MOD_License_Feature {
    #[doc = "Opaque pointer to host data.\n\nThis MUST be passed to license() and free() whenever they are called.\nOtherwise, it must not be interpreted in any way."]
    pub handle: MOD_License_Handle,
    #[doc = "Ask the host about a license file for a specific uri\n(can be the plugin uri or a collection).\n\nThe host will return the contents of the file, signed and encrypted,\nor NULL if no license exists.\n\nThe plugin must call free() on the returned data.\n\n@param handle Must be the handle member of this struct.\n@param license_uri The uri for which to ask a license for."]
    pub license: ::std::option::Option<
        unsafe extern "C" fn(
            handle: MOD_License_Handle,
            license_uri: *const ::std::os::raw::c_char,
        ) -> *mut ::std::os::raw::c_char,
    >,
    #[doc = "Free the returned data of a license() call.\n\n@param license The data to be freed."]
    pub free: ::std::option::Option<
        unsafe extern "C" fn(handle: MOD_License_Handle, license: *mut ::std::os::raw::c_char),
    >,
}
#[doc = "MOD License Feature (MOD_LICENSE__feature)"]
pub type MOD_License_Feature = _MOD_License_Feature;
extern "C" {
    #[doc = " Check license file for a specific uri (plugin or collection).\n\n Must be called at instantiate(), one time for each license uri.\n\n Returns true if a valid license was found or host doesn't support licensing API.\n (so that you can stop checking for other license uris)"]
    pub fn mod_license_check(
        features: *const *const LV2_Feature,
        license_uri: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Begin time calculations for unlicensed silence.\n\n Must be called at the beginning of each run().\n This counts samples (time) to later decide if silence needs to be injected.\n\n Returned value must be stored in the local 'run_count'."]
    pub fn mod_license_run_begin(run_count: u32, n_samples: u32) -> u32;
}
extern "C" {
    #[doc = " DEPRECATED\n\n Before version 1.2 we used noise. We changed it, because even noise\n at low levels can grow to maximum level through the signal\n chain. This may damage speakers and hearing.\n\n We keep the function signature to not break compilation, since\n programmers happen to fork e.g. old versions of DPF which make use\n of `mod_license_run_noise`."]
    pub fn mod_license_run_noise(run_count: u32, buf: *mut f32, n_samples: u32, chn: u32);
}
extern "C" {
    #[doc = " Inject silence into output buffers if unlicensed.\n\n Must be called at the end of each run(), for all audio output buffers.\n Call this function on each buffer, using @a chn to specify the index offset."]
    pub fn mod_license_run_silence(run_count: u32, buf: *mut f32, n_samples: u32, chn: u32);
}
extern "C" {
    #[doc = " Get the LV2 interface for the MOD license API.\n\n Must be called at the end of your lv2 plugin extension_data."]
    pub fn mod_license_interface(
        uri: *const ::std::os::raw::c_char,
    ) -> *const ::std::os::raw::c_void;
}
extern "C" {
    #[doc = " Return the version of modla library.\n"]
    pub fn mod_license_version() -> *const ::std::os::raw::c_char;
}
